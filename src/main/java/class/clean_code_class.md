# Clean Code

## 클래스 체계
- 변수 목록 다음에는 공개함수가 나오고, 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다.
- 즉, 추상화 단계가 순차적으로 내려가 신문 기사처럼 읽힌다.

### 캡슐화
- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 한다는 법칙도 없다.
- 하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다. 캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.

## 클래스는 작아야 한다
- 클래스는 작은 것이 옳다.
- 클래스 이름은 해당 클래스 책임을 기술해야 한다.
- 간결한 이름이 떠오르지 않는다면 필경 클래스 크기가 너무 커서 그렇다.
- 이름이 모호하다면(ex. `Processor`, `Manager`, `Super`) 필경 클래스 책임이 너무 많아서다.
- 클래스 설명은 만일, 그리고, ~거나, 하지만을 사용하지 않고서 25단어 내외로 가능해야 한다.

### 단일 책임 원칙
- 클래스나 모듈을 변경할 이유는 하나뿐이여야 한다.
- 클래스는 책임, 즉 변경할 이유가 하나여야 한다.
- 소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동은 완전히 별개다.
- 우리의 두뇌는 깨끗하고 체계적인 소프트웨어보다 돌아가는 소프트웨어에 초점을 맞춘다.
- 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 당장 알필요가 없는 사실까지 들이밀어 독자를 방해한다.

### 응집도
- 클래스는 인스턴스 변수 수가 작아야 한다.
- 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다.
- 아래 클래스는 응집도가 아주 높다.

```java
public class Stack {
	private int topOfStack = 0;
	List<Integer> elements = new LinkedList<Integer>();

	public int size() { 
		return topOfStack;
	}

	public void push(int element) {
		topOfStack++;
		elements.add(element);
	}
	
	public int pop() throws PoppedWhenEmpty { 
		if (topOfStack == 0)
			throw new PoppedWhenEmpty();
		int element = elements.get(--topOfStack); 
		elements.remove(topOfStack);
		return element;
	}
}
```

- 때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다.
- 이는 십중팔구 새로운 클래스로 쪼개야 한다는 신호다.
- 응집도가 높아지도록 변수와 메서드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다.

### 응집도를 유지하면 작은 클래스 여럿이 나온다.
- 클래스가 응집력을 잃는다면 쪼개라.
- 클래스가 쪼개질 수록 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.

## 변경하기 쉬운 클래스
- 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다.
- 새 기능을 수정하거나 기존 기능을 변경할 떄 건드릴 코드가 최소인 시스템 구조가 바람직하다.
- 이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지는 않는다.

### 변경으로부터 격리
- 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성도 더욱 높아진다.
- 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미이다.
- 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기도 더 쉬워진다.
- 이렇게 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP를 따르는 클래스가 나온다.
